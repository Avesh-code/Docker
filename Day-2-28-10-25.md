# Docker Documentation  
## 1. Dockerfile for Python Project  
* cloning project repository
```
git clone https://github.com/LondheShubham153/flask-app-ecs.git
```
* Creting Dockerfile
```
FROM python:3.7

WORKDIR /app

COPY . .

RUN pip install -r requirements.txt

ENTRYPOINT ["python","run.py"]

```
* Then we used command to make a image and run that image
```
docker build -t python-app .
docker run python-app
```
## 2. Dockerfile for Node Project 
* cloning project repository
```
git clone https://github.com/LondheShubham153/node-todo-cicd.git
```
* Creting Dockerfile
```
FROM node:12.2.0-alpine

WORKDIR /app

COPY . .
#install dependencies
RUN npm install
RUN npm run test
EXPOSE 8000
# run the code 
CMD ["node","app.js"]

```
* Then we used command to make a image and run that image
```
docker build -t node-app .
docker run -d node-app
docker logs c4e44fcae5e4
docker attach c4e44fcae5e4
```
## 3. Dockerfile keyword  
* `FROM` : Specifies the base image to use for your container. Every Dockerfile must start with a FROM instruction.
* `WORKDIR` : Sets the working directory inside the container for any following instructions such as RUN, CMD, COPY, or ENTRYPOINT. If the directory doesn’t exist, it gets created automatically.
* `COPY` : Copies files or directories from your local source (host) into the Docker image.
* `RUN` : Executes a command during the image build process, creating a new image layer. Common uses are installing packages or building your app.
* `ENTRYPOINT` : Sets a fixed command that will always run when the container starts. It is meant to define the main application
* `CMD` : Sets default parameters for ENTRYPOINT or a command to execute if ENTRYPOINT is not specified. This can be overridden when you run the container.
* `EXPOSE` : Documents which ports the container will listen on at runtime, for inter-container communication.

### ENTRYPOINT VS CMD  
| Feature             | ENTRYPOINT                                                                 | CMD                                                                                  |
|---------------------|---------------------------------------------------------------------------|--------------------------------------------------------------------------------------|
| Purpose             | Runs a fixed command every time the container starts                      | Provides default arguments or command                                               |
| Overriding Behavior | Can only be overridden with `--entrypoint` flag                          | Can be overridden by supplying different arguments in `docker run` command         |
| Usage Scenario      | When you want consistent container behavior (e.g., web server or utility) | When you want flexibility to change command or args at runtime                      |
| Combined Use        | Can be combined with CMD to pass default parameters                       | Works with ENTRYPOINT as default parameters                                         |
| Example             | `ENTRYPOINT ["python", "app.py"]`                                         | `CMD ["--debug"]` – default argument that can be changed                            |
| Runtime Effect      | Always runs the ENTRYPOINT command                                        | Runs only if no command is passed at container start                               |
| Flexibility         | Less flexible; fixed command                                              | More flexible; easily overridden                                                    |

## 4. Docker commands  
* it is for getting logs of specific container
```
docker logs <ContainerID>
```
* It is used for getting Logs in Realtime
```
docker attach <containerId>
```
* it is used to stop any container using id
```
docker stop <containerid>
```
* It is used to start the container again
```
docker start <containerId>
```
* it is used to execute the container
```
docker exec -it <container-id> bash
```
## 5. Docker Networking
* Docker networking is the system that allows Docker containers to communicate with each other, with the Docker host, and with external networks. It provides network isolation, connectivity, and flexibility for containerized applications.

| Network Type           | Description                                               | Use Case                              |
|------------------------|-----------------------------------------------------------|-------------------------------------|
| **bridge**             | Default private network on a single host.                 | Containers on one host communication.|
| **user-defined bridge**| Custom bridge with better isolation and DNS support.      | Advanced multi-container setups.     |
| **host**               | Shares host network stack; no isolation.                   | High performance, direct host access.|
| **none**               | No network (isolated container).                           | Secure, no network needed.            |
| **macvlan**            | Containers get unique MAC/IP, appear as physical devices. | Legacy apps needing LAN access.       |
| **ipvlan**             | Similar to macvlan but shares host MAC, separate IPs.     | Scalable networks with VLAN support. |
| **overlay**            | Connects containers across multiple hosts.                 | Distributed apps on multiple hosts.   |

some Commands:  
* for list docker network
```
docker network ls
```
* for creating the new network of bridge type
```
docker network create mynetwork -d bridge
```
## 6. Project:2-tier Flask Application on same network  
* 1. Clone the project 
```
git clone https://github.com/LondheShubham153/two-tier-flask-app.git
```
* 2. Build the Dockerfile

Dockerfile
```
# Use an official Python runtime as the base image
FROM python:3.9-slim

# Set the working directory in the container
WORKDIR /app

# install required packages for system
RUN apt-get update \
    && apt-get upgrade -y \
    && apt-get install -y gcc default-libmysqlclient-dev pkg-config \
    && rm -rf /var/lib/apt/lists/*

# Copy the requirements file into the container
COPY requirements.txt .

# Install app dependencies
RUN pip install mysqlclient
RUN pip install --no-cache-dir -r requirements.txt

# Copy the rest of the application code
COPY . .

# Specify the command to run your application
CMD ["python", "app.py"]

```

Run command
```
docker build -t two-tier-backend-app .
```
> NOTE : i have used mysql which i have mad a container previously and also i have created the database using `exec`.

* 3. Creating a Network for both the container

```
docker network create two-tier -d bridge
```

* 4. Running the mysql container which i have already . with parameters
```
docker run -d --name mysql --network two-tier -e MYSQL_ROOT_PASSWORD=root -e MYSQL_DATABASE=devops mysql
```

* 5. Running the Two-tier Application with Flask and mysql
```
docker run -d -p 5000:5000 --network two-tier -e MYSQL_HOST=mysql -e MYSQL_USER=root -e MYSQL_PASSWORD=root -e MYSQL_DB=devops two-tier-backend-app:latest
```
* 6. check logs and check the database
```
docker logs 8f1f266c9f8f
```
* if the message is updated in database then the network is working good!
