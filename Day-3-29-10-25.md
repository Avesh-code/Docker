# Docker Documentation  
## 1. Docker compose
* Docker Compose is a tool used for defining and running multi-container Docker applications. With Compose, you define your application's services, networks, and volumes in a YAML file, typically called docker-compose.yml

| Command             | Description                                                        |
|---------------------|--------------------------------------------------------------------|
| `docker compose up`  | Builds, (re)creates, starts, and attaches to containers for a service. |
| `docker compose down`| Stops and removes containers, networks, volumes, and images created by `up`. |
| `docker compose build`| Builds or rebuilds services.                                      |
| `docker compose ps`  | Lists containers related to your Compose project.                  |
| `docker compose logs`| Fetches logs for all or specific containers.                       |  
| `docker compose up -d` | It will start in detached mode                                   |    

* also used the Docker composed in two tier project and written the `docker-compose.yml` file and run it using commands so here is the docker compose file.
> docker-compose.yml

```
services:
  mysql:
    container_name: mysql
    image: mysql
    environment: 
     MYSQL_DATABASE: "devops"
     MYSQL_ROOT_PASSWORD: "root"
    ports:
      - "3306:3306"
    volumes:
      - mysql-data:/var/lib/mysql
    networks:
      - two-tier
    restart: always
    healthcheck:
      test: ["CMD", "mysqladmin", "ping", "-h", "localhost", "-uroot", "-proot"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 60s

  flask:
    build: 
     context: .
    container_name: two-tier-backend-app
    ports: 
      - "5000:5000"
    environment:
      MYSQL_HOST: mysql
      MYSQL_USER: root
      MYSQL_PASSWORD: root
      MYSQL_DB: devops
    networks:
      - two-tier
    depends_on:
      - mysql
    restart: always
    healthcheck:
      test: ["CMD-SHELL", "curl -f http://localhost:5000/health || exit 1"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 30s

volumes:
  mysql-data:

networks:
  two-tier:

```
* some commands for deleting images and containers
```
# for deleting one image
docker rmi <imageid>
# for deleting multi images
docker rmi <imageid> <imageid>
# for deleting all images
docker rmi -f $(docker images -aq)
# for deleting one comtainer 
docker rm <containerid>
# for deleting multi containers
docker remove <containerid> <containerid>
# for deleting all containers
docker rm $(docker ps -aq)
```
## 2. Docker registry  

* 1. Login to dockerhub using cli
```
docker login
```
> NOTE : login using a PAT (personal access token)
* 2. tag the docker image
```
docker image tag <image-name> <username>/<new-image-name>:lattest
```
> NOTE : the username should of Docker hub account
* 3. push the image to docker hub
```
docker push <username>/<new-image-name>:lattest
```

## 3. Multi-Stage Builds in Docker
* Multi-stage builds in Docker let you create smaller and more efficient images by separating the build environment from the runtime environment in a single Dockerfile.

### What are Multi-Stage Builds?

- A Dockerfile contains multiple `FROM` instructions, each representing a separate build stage.
- You can name these stages using `AS <name>`.
- The final image is built from the last stage, and you can **selectively copy artifacts** (binaries, files) from earlier stages using `COPY --from=<stage_name>`.
- This process keeps **build dependencies and intermediate files** out of the final image, resulting in a **lighter and more efficient container**.
- Example Dockerfile:
```
# Stage 1: Builder
FROM python:3.7 AS builder

WORKDIR /app
COPY requirements.txt .
RUN pip install --user -r requirements.txt

COPY . .

# Stage 2: Final
FROM python:3.7-slim

WORKDIR /app

# Copy installed Python packages from builder's user site
COPY --from=builder /root/.local /root/.local

# Copy application code
COPY --from=builder /app /app

# Set environment PATH for user-installed binaries
ENV PATH=/root/.local/bin:$PATH

ENTRYPOINT ["python", "run.py"]

```

## 4. Monitoring and logging in Docker  
